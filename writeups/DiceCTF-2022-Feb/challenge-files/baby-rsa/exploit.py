from Crypto.Util.number import *

n = 57996511214023134147551927572747727074259762800050285360155793732008227782157
e = 17
c = 19441066986971115501070184268860318480501957407683654861466353590162062492971

p = 172036442175296373253148927105725488217
q = 337117592532677714973555912658569668821

assert(p * q == n)

def algorithm_1 ():
  phi = (p - 1) * (q - 1) // (e ** 4)
  g = 1

  while True:
    g += 1
    g_e = pow(g, phi, n)
    if g_e != 1:
      yield g_e

def rsa_crt_precompute (p, q):
  N = p * q
  pinv = pow(p, -1, q)
  qinv = pow(q, -1, p)
  Mp = qinv * q % N
  Mq = pinv * p % N
  return (Mp, Mq)

def rsa_crt_mod_exp (x, a, p, q, Mp, Mq):
  N = p * q
  xp = x % p
  xq = x % q
  ap = a % (p - 1)
  aq = a % (q - 1)
  yp = pow(xp, ap, p)
  yq = pow(xq, aq, q)
  y = (yp * Mp + yq * Mq) % N
  return y

for g_e in algorithm_1():
  Mp, Mq = rsa_crt_precompute(p, q)
  phi_hat = (p - 1) * (q - 1) // (e ** 4)
  d = pow(e, -1, phi_hat)
  g_e_torsion = rsa_crt_mod_exp(g_e, phi_hat, p, q, Mp, Mq)
  z = rsa_crt_mod_exp(c, d, p, q, Mp, Mq)
  ell = g_e_torsion

  for i in range(e ** 4):
    pt_hat = ell * z % n
    m = long_to_bytes(pt_hat)

    if b'dice' in m:
      print(m)
      exit()
    ell = ell * g_e_torsion % n

# dice{cado-and-sage-say-hello}
